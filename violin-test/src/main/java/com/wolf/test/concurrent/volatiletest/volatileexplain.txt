用volatile修饰的变量，线程在每次使用变量的时候，都会读取变量修改后的最的值。volatile很容易被误用，不能用来进行原子性操作。
由于volatile仅仅保证对单个volatile变量的读/写具有原子性，而监视器锁的互斥执行的特性可以确保对整个临界区代码的执行具有原子性。
在功能上，监视器锁比volatile更强大；在可伸缩性和执行性能上，volatile更有优势。


理解volatile特性的一个好方法是：把对volatile变量的单个读/写，看成是使用同一个监视器锁对这些单个读/写操作做了同步。
监视器锁的happens-before规则保证释放监视器和获取监视器的两个线程之间的内存可见性，这意味着对一个volatile变量的读，
总是能看到（任意线程）对这个volatile变量最后的写入

volatile提供内存可见性，强制线程使用主内存而不是自己的内存。通过插入内存屏障防止jvm对指令进行重拍(例如：双重检查锁、上下文和true的关系)


volatile会禁用处理器的快速的访问内存或寄存器，直接从主内存中取。所以对于成员变量，如果有多线程访问，
加上violatile就可以让他们都从一个地方读取，不过这个不能保证原子执行，只能保证能看到最新的。
不过由于大家都没有本地缓存势必性能有所影响，而且volatile也禁止jvm优化指令重排
只能保证可见性，不能保证原子性，那么多读少写的情况，能不能对写操作进行同步而不管读？可以的。

volatile能代替countdownlatch，轻量级

volatile写之前读之后，写读，不能重排序

多线程问题，原子性，可见行，重排序