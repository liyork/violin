用volatile修饰的变量，线程在每次使用变量的时候，都会读取变量修改后的最的值。volatile很容易被误用，不能用来进行原子性操作。
由于volatile仅仅保证对单个volatile变量的读/写具有原子性，而监视器锁的互斥执行的特性可以确保对整个临界区代码的执行具有原子性。
在功能上，监视器锁比volatile更强大；在可伸缩性和执行性能上，volatile更有优势。


理解volatile特性的一个好方法是：把对volatile变量的单个读/写，看成是使用同一个监视器锁对这些单个读/写操作做了同步。
监视器锁的happens-before规则保证释放监视器和获取监视器的两个线程之间的内存可见性，这意味着对一个volatile变量的读，
总是能看到（任意线程）对这个volatile变量最后的写入

volatile提供内存可见性，强制线程使用主内存而不是自己的内存。通过插入内存屏障防止jvm对指令进行重拍(例如：双重检查锁、上下文和true的关系)