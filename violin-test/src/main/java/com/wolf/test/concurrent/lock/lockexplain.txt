对于每个线程独有的变量，不需要加锁
对于共享的数据，仅仅只有读操作，即此对象是不可变的，不需要加锁（初始化时需要使用final修饰,能保证单线程初始化）
例如concurrenthashmap是线程安全的，但是如果有get后再set这种复合操作也需要手动加锁。

如果程序获取锁失败：
1.自旋等待，程序继续被调度执行(不断重试)
2.阻塞等待，程序阻塞，不会被调度。

锁的过程是对某个对象进行原子操作(compareandset基于某个原值设定新值),synchronized是对对象本身或者class进行设定，lock是对unsafe对象进行设定

正确的使用锁,分析应用场景，意识到有并发则该加的加，
尽量减少锁的范围,尽量减少锁的粒度(可以分拆，不同的模块或者用户不同锁),读 - 写锁，不可变对象，以及原子变量。Thread Local 的数据

锁应用场景：
1.多个操作合并在一起，例如从银行取钱然后再加入1块再放入，这个所有操作都得是线程安全的，
2.查看和取钱/存钱就能用到读写锁，所有人拿着一个银行卡都去查看没有问题不会锁，一旦有人存钱或者取钱，则后续人不能立即查看，
同理一旦有人查看，也不能进行存钱和取钱
3.十字路口，横向和纵向两个方法也必须是加锁的
4.存钱和取钱也不能同时进行


悲观锁适合写操作非常多的场景，乐观锁适合读操作非常多的场景，不加锁会带来大量的性能提升。
分段锁的设计目的是细化锁的粒度
偏向锁，有其他线程访问则清量锁，线程自旋，自旋一定次数后重量锁