对于多线程资源共享的问题，同步机制采用了“以时间换空间”的方式，而ThreadLocal采用了“以空间换时间”的方式

ThreadLocal适用于资源共享但不需要维护状态的情况，也就是一个线程对资源的修改，不影响另一个线程的运行；这种设计是空间换时间，synchronized顺序执行是时间换取空间。

公用的ThreadLocal变量因为本身定位为要被多个线程来访问，通常是静态的(私有的就没事了)，注意他返回的数据如果是引用，则有可能是所有线程都有这个引用，所以最好都new

理论上threadlocal没有泄露问题：threadlocal内部只有一个hashcode实例变量。而每个线程关联的map的key是弱引用threadlocal，
而每次set或get都会引发消除无效的key关联的value，可能担心的是threadlocal都是静态实例变量，
这个强引用一般不会断，而jvm可能不会回收有强引用和弱引用的对象，导致无用的value因为threadlocal一直在导致泄漏，
一般比较好的做法是每个线程用完就remove掉就好了。

应用：
数据多个副本，每个线程各跑各的
数据库连接使用
Struts2的action和service层之间解耦request和response
hibernate管理session

ThreadLocal建议
ThreadLocal应定义为静态成员变量。
能通过传值传递的参数，不要通过ThreadLocal存储，以免造成ThreadLocal的滥用。
在线程池的情况下，在ThreadLocal业务周期处理完成时，最好显式的调用remove()方法，清空”线程局部变量”中的值。
正常情况下使用ThreadLocal不会造成内存溢出，弱引用的只是threadLocal，保存的值依然是强引用的，如果threadLocal依然被其他对象强引用，”线程局部变量”是无法回收的。
线程中有各自的map，而把ThreadLocal实例作为key，这样除了当线程销毁时相关的线程局部变量被销毁之外，还让性能提升了很多。

* 为什么在threadLocal中定义一个map，key：threadid，value：threadlocal，实际在thread内部维护map，
 * 而不在threadlocal中存放map存放所有关联线程？
 * 现在的结构是：threadlocal只是定义一个数据结构map然后操作thread内部的变量map，每个线程有自己的map，线程可以清空内部map，存放其他threadlocal或者不使用时直接连同map一起回收
 * 而如果threadlocal中存放线程关系，会出现多线程问题(多个线程访问一个threadlocal，这个threadlocal需要加锁)
 * 而且threadlocal中存放线程关系，关联所有线程，不易垃圾回收无用的线程，导致连接过多，内存占用过多(还需要当前线程自己清除自己对应的关系)

 * ThreadLocal不是用来解决对象共享访问问题的，而主要是提供了保持对象的方法和避免参数传递的方便的对象访问方式。