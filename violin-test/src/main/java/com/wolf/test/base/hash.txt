哈希函数是实现将一个大范围内的数字转化为一个小范围的数字

解决hash冲突方法

1.开放地址法
H表示hash,d表示增量序列，m表长
Hi=（H（key）+di）% m   i=1，2，…，n
线性探测
dii=1，2，3，…，m-1
二次探测再散列
di=1^2，-1^2，2^2，-2^2，…，k^2，-k^2    ( k<=m/2 )
伪随机探测再散列
di=伪随机数序列。
(线性探测、二次探测(x+1,x+4,x+9))并不常用

2.再哈希法(不易产生聚集，但增加了计算时间。)
为了消除原始聚集和二次聚集，可以采用另一种解决冲突方法：再哈希法。
二次聚集产生的原因是二次探测算法产生的探测序列步长总是固定的，如1,4,9,16等，再哈希依赖关键字的探测序列，
方法就是把不同的关键字用不同的哈希函数再做一遍哈希化(reStepSize=size-(hash(key)%size))，用这个结果作为步长

探测序列通常使用再哈希法生成

3.链地址法(适用于经常进行插入和删除的情况)

4.建立公共溢出区

hash表的容量通常设置成一个质数，采用质数作为数组容量会保证探测到每一个单元(例如：length=10,step=5,搜索0,5,0,5)。

如果使用开发地址法，对应小型的哈希表，再哈希应该比二次探测效果好，但如果内存足够，并且哈希表容量在创建后不再改变，这时线性探测相对容易实现。
并且如果装填因子如果小于0.5，解决冲突时性能基本没有下降
相比于链表，不用创建链表省开销。

如果在创建哈希表时，要填入的项数未知，链地址法要比开发地址法更合适。因为开放地址数字装填因子的变大，性能会下降的很快，而链地址法，性能只是线性地下降。

hash表中的数据项和表长的比例叫做装填因子
在链地址法中，需要在有N个单元的数组中装入N个或多个数据项；因此装填因子一般为1，或者比1大。在装填因子大约为1的情况下，平均1/3的单元是空白单元；
1/3的单元只有一个数据项，1/3有两个或更多的数据项。 如果链表中有许多项，存取时间就会变长，因为存取特定数据项平均需要搜索链表的一半数据项。
找到初始单元需要O(1)的时间级，而搜索链表的时间与M成正比，M为链表包含的平均项数。即O（1+M）的时间级，因此并不希望链表太满。
链地址法是更健壮的机制，特别是当事先难以确定哈希表存储多少数据时。

在开放地址中，平均探测长度（以及平均存取时间）取决于装填因子。随着装填因子变大，探测长度越来越长。当装填因子超过1/2后2/3后，性能下降的很快。
